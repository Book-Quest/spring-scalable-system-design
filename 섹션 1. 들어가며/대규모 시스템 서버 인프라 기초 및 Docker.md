# 대규모 시스템 서버 인프라 기초

![image](https://github.com/user-attachments/assets/33d01985-e8e0-4459-b683-f36c4fd9fc25)
- Client가 Server로 요청을 보내고, Server는 요청에 대해 필요한 작업을 수행
- Server가 Client 요청을 처리하면서 데이터베이스에서 상태를 관리

![image](https://github.com/user-attachments/assets/ef416ea7-c106-4e8d-8c52-ac192b88fdec)


⚠️ Client 요청 ⬆️ ⇒ 서버의 리소스 부족으로 단일 서버, 단일 애플리케이션에서 감당 불가능

✅ Scale-Up은 한계가 있으므로 Scale-Out으로 여러 서버에서 애플리케이션을 실행하여 처리를 분산시킴

- **Scale-up (수직 확장)** : 단일 서버의 성능을 향상시키는 것
    
    ex) CPU나 메모리 업그레이드
    
- **Scale-Out (수평 확장)** : 서버를 추가하여 성능을 향상시키는 것

|  | **Scale-up (수직 확장)** | **Scale-Out (수평 확장)** |
| --- | --- | --- |
| **확장성** | 성능 확장에 한계 | 지속적 확장 가능 |
| **서버 비용** | 성능 증가에 따른 비용 부담 ⬆️ | 비용 부담 ⬇️ |
| **관리 편의성** | 큰 변화 없음 | 서버 대수가 늘어날 수록 관리 편의성 떨어짐 |
| **장애 영향** | 한 대의 서버에 부하가 집중되므로 장애 시 다운 타임 발생 | 부하가 여러 서버에 분산되어 처리됨으로 장애시 전면 장애 가능성 적음 |

![image](https://github.com/user-attachments/assets/ed40c0a5-1649-444d-bd28-613c206641b8)

- Client는 로드밸런서로 요청을 보내고, 로드밸런서는 요청을 적절히 분산하여 서버로 전달
    - **Load Balancer** : 트래픽을 라우팅 및 분산하기 위한 도구. 트래픽이 과도하게 몰려 서비스가 중단되는 것을 막고 지연 없이 작업을 처리.
    - **Load Balancing** : 여러 서버나 컴퓨터 자원이 작업을 고르게 분산하는 기술
        
        ex) 웹 사이트에 들어오는 트래픽을 여러 서버에 분산시켜 하나의 서버에 부담이 가지 않도록 하는 것이 주 목적
        
- Scale-Out 시 서버가 여러 대가 되므로 각 서버에 걸리는 부하를 고르게 나누기 위해 로드밸런싱이 필수

![image](https://github.com/user-attachments/assets/f3203f7a-7f57-4d46-ad5e-5c0cf614debc)

- Scale-Out은 로드밸런서와 데이터베이스에서도 처리 가능함

![image](https://github.com/user-attachments/assets/ec6d3f41-97af-44f0-b009-479f226637b7)

⚠️ Client가 요청을 처리하는 과정이 복잡할 수록 응답이 느려짐

✅ 캐시(Cache)를 사용하여 더 빠른 성능

- Cache : 더 느린 저장소에서 더 빠른 저장소에 데이터를 저장해두고 접근하는 기술. 주로 메모리에 저장되며, 데이터베이스나 원격 서버에 비해 접근 속도가 빠름.
    - 목적 : 데이터 접근 속도를 향상시키고, 시스템 부하를 줄이는 것
    - 종류 : (1) 브라우저 자체 캐시, (2) DNS 쿼리 결과 캐시, (3) DB보다 빠른 데이터 접근, (4) CDN 기술
 
![image](https://github.com/user-attachments/assets/c9a7090e-e1d7-4511-b7aa-7698fe20c911)

⚠️ 안정성 문제

- 네트워크는 안전하기 않기 때문에 순단 가능
- 시스템 오류나 자연 재해 등으로 서버와 데이터는 언제든 중단 및 유실 가능
- 지리적인 거리로 인한 응답 시간 지연

✅ 서버가 설치된 데이터 센터를 다중화

![image](https://github.com/user-attachments/assets/6ef77d4d-926f-4bc0-8a7f-65362abd92cb)

⚠️ 단일 애플리케이션은 커질수록 관리가 어려움.

- 단일 서버가 처리해야할 트래픽⬆️ ⇒ 리소스 부족 문제
- 시스템⬆️ ⇒ 애플리케이션의 유지보수 어려움


✅ 단일 애플리케이션을 기능에 맞는 여러 개의 애플리케이션으로 분리하여 관리

- 각 애플리케이션은 담당한 기능에 대해 개별 작업만 수행. 데이터베이스도 기능별로 분리 가능
- 분리된 웹 애플리케이션이 하나의 서비스를 이루기 위해 서로 API나 메시지(이벤트)를 통해 네트워크 통신을 수행


# Docker
- 애플리케이션을 컨테이너라는 격리된 환경에서 실행할 수 있게 해주는 플랫폼
- 컨테이너 기반의 오픈소스 가상화 플랫폼으로, 다양한 프로그램들과 실행환경을 컨테이너로 규격화시켜 프로그램의 배포 및 관리를 단순화
- 실행에 필요한 모든 dependency들도 컨테이너에 담기 때문에 다른 환경에서도 빠르게 애플리케이션을 실행 가능
- 
![image](https://github.com/user-attachments/assets/1b9bd987-cbfa-4f6b-8893-d825857c87ac)

- 프로그램은 이미지(실행 파일)로 패키징되고, 컨테이너(실행된 프로세스)로 실행됨
- **이미지** : 애플리케이션 실행을 위한 템플릿
    - 도커에서 서비스 운영에 필요한 서버 프로그램, 코드 및 라이브러리, 컴파일된 실행 파일 등을 묶는 형태
- **컨테이너** : 실행된 이미지로, 독립적이고 격리된 실행 환경
    - 가상화 기술 중 하나로 OS레벨의 가상화로 프로세스를 격리시켜 동작하는 방식

### ❓ **어떻게 개발/실행 환경이 달라도 컨테이너로 규격화한 프로그램들이 정상적으로 작동할까?**

☑️ 도커 컨테이너들이 도커엔진 위에서 실행되므로 도커가 설치되어 있는 곳이라면 실행환경에 상관없이 모든 환경에서 동일하게 작동 가능

![image](https://github.com/user-attachments/assets/142950a8-2638-4701-b1df-f5efa841cfe2)

### 도커와 가상머신의 차이점

![image](https://github.com/user-attachments/assets/36eb748b-3f0c-430b-9e43-51489a8d82e7)


| **구분** | **도커 (컨테이너 기술)** | **가상머신 (VM)** |
| --- | --- | --- |
| **추상화 레벨** | App Layer에서의 추상화 | 하드웨어 레벨에서의 추상화 |
| **OS 커널** | 여러 컨테이너가 동일한 호스트 OS 커널을 공유 | 각 VM이 독립적인 게스트 OS를 가지고 있음 |
| **실행 환경** | Docker 엔진 위에 애플리케이션 실행에 필요한 바이너리만 올림 (실행 환경만 독립적) | 완전한 OS, 애플리케이션, 라이브러리를 포함 (완벽한 게스트와 호스트 분리) |
| **크기** | 수십 ~ 수백 MB의 작은 크기 | 하나당 GB 단위로 큰 크기 |

---

### 참고자료

https://www.smileshark.kr/post/what-is-a-load-balancer-a-comprehensive-guide-to-aws-load-balancer
