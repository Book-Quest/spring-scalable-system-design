# CQRS란?

- 데이터에 대한 변경(Command)과 조회(Query)의 책임을 분리하는 패턴
- 클래스, 패키지, 서비스, 데이터 저장소 레벨 등 좁거나 넓은 범위에서 책임 분리가 일어날 수 있음
- 서비스간의 종속을 마이크로서비스 레벨에서 분리하는 것이 가능

# CQRS를 구현하는 방법

- Query용 DB 별도로 구축
    - command 서버에서 실시간으로 가져오면, 부하가 전파되는 문제가 남아있음
        - 조회를 자체 DB 구축

본체의 데이터 실시간 변경 사항을 어떻게 가져올 수 있을까?

- 데이터를 실시간으로 받는 법
    - API를 통해 주기적으로 변경사항 polling
        - API의 문제점: 부하 및 장애 전파, 결합도 증가, 동기화 지연
    - Message Broker (Kafka) 활용

- Query에서 조인 비용을 줄이고, 조회 최적화를 위해 필요한 데이터가 비정규화된 query 모델을 만들어야 함
    - Query Model = 게시글 + 댓글수 + 좋아요수
    - 단건만 조회하면 필요한 데이터 모두 조회 가능
- In-memory DB Redis 활용
    - 메모리 기반이라 빠르게 데이터를 제공할 수 있지만, 비용 발생
    - 최신글이 조회되는 경우가 많으므로 TTL을 1일로 설정해 24시간 이내의 최신글만 Redis에 보관
    - Redis에 데이터가 만료된 경우 Command 서버로 원본 데이터를 다시 요청해 Query Model 만듬
        - 만료된 데이터만 간헐적으로 요청해 트래픽이 크지 않고, 장애, 이벤트 누락, 데이터 유실 등의 상황에 원본 데이터 서버로 질의해 가용성을 높일 수 있음
        - 장애 전파에 대한 위험성 검토 필요

# Query Model에 조회수를 비정규화하지 않은 이유

- 조회수는 읽기 트래픽이 생기면 따라서 올라감. 조회 성능을 위해 비정규화.
- 읽기 트래픽에 의해 쓰기 트래픽도 발생 가능
    - 조회수가 변경될 때마다 Query Model을 만드는 것은 비효율적. Redis에 이미 저장되어 있기 때문에 백업 시점에만 전송. (실시간일 이유가 x)
- 조회수 서비스로 직접 요청하기
    - 짧은 만료 시간이라도 캐시해서 부하를 줄이자
    - 캐시 최적화 전략을 사용해 더욱 개선 가능

# 실제 사례

## Handbook

<img width="200" height="228" alt="Image_2025-06-17 16_20_52" src="https://github.com/user-attachments/assets/608fa357-a8dc-428b-a7bd-1d3201fb6cfc" />

- 예를들어 search라는 하나의 모듈이 있음
    - 이를 읽기, 쓰기로 나눠서 구현
        - 쓰기보다 읽기 작업이 많고, 읽기 작업이 동시다발적으로 이루어지기 때문에 나누어서 구현

## 우아한 형제들

- 우아한형제들의 B마트 서비스는 전시 도메인에 한정하여 CQRS를 적용하여 고객에게 카탈로그와 상품을 전시

<img width="582" height="481" alt="image (3)" src="https://github.com/user-attachments/assets/c553b1a2-510c-4e8c-bd1c-afd1d379c213" />


### CQRS 적용 배경

1. 카탈로그는 자식 카탈로그를 갖고, Leaf 카탈로그에만 상품이 등록됩니다.
2. 카탈로그는 자식 카탈로그에 등록된 상품 전체를 노출하며, 판매 가능한 상품이 있는 카탈로그만 노출됩니다.
3. 초기에는 카탈로그 전체 트리에서 모든 카탈로그를 보여주는 단순한 로직이었으나, 점차 복잡한 큐레이션 섹션이 추가되었습니다.
4. 복잡해진 비즈니스 정책과 개인화 요소로 인해 전체 트리 모델이 비대해졌습니다.
5. 외부 데이터를 주입받아 결과를 반환하는 비즈니스 로직이 많아지면서 전체 트리 모델의 의존성이 증가하고, 스파게티 코드가 생겼습니다.
6. Redis 부하가 심해지며 latency가 발생하여 서비스 품질이 저하되었습니다. 이를 보완하기 위해 사방 팔방으로 LocalCache와 Cache를 사용했습니다.
7. Redis로 가는 트래픽을 감소시켰지만 그만큼 서버의 힙 메모리 사용량이 증가하고, 데이터 정합성을 보장하지 못하는 문제가 발생하였습니다.

- 결국 카탈로그와 상품을 등록하는, 명령 모델을 사용하는 팀과 해당 데이터를 조회하는, 조회 모델을 이용하는 팀이 분리됨에 따라 별도의 조회 모델을 설계하여 CQRS 패턴을 도입

### 조회 모델 (Read Model) 설계

1. 전체 트리 모델의 의존성을 줄이기 위해 조회 모델을 재설계했습니다.
2. 기존 비즈니스 로직에서 전체 트리 모델 의존성을 줄이고 필요한 데이터만 제공하는 조회 모델로 정리했습니다.
3. 노출 가능 카탈로그 목록, 카탈로그 및 상품 목록 제공으로 조회 모델을 단순화했습니다.
4. 조회 모델은 비정규화된 형태로 성능 최적화를 달성했습니다.
5. 조회 모델로 캐시 트래픽 부담을 줄이고, 명령 모델에서 변경 사항을 이벤트로 전달하는 이벤트 소싱 패턴을 도입했습니다.

<img width="670" height="404" alt="image (5)" src="https://github.com/user-attachments/assets/b84bd16a-13e1-4528-853e-185e578d759c" />

<img width="667" height="346" alt="image (6)" src="https://github.com/user-attachments/assets/a87c48cf-4cca-42a1-a0a3-a3ba51d2a0f2" />

<img width="806" height="510" alt="image (7)" src="https://github.com/user-attachments/assets/2952d8cc-a3f6-4c85-99f0-41cc483777ec" />

<img width="567" height="413" alt="image (8)" src="https://github.com/user-attachments/assets/b6be32bb-9eac-4f22-9912-11b47e8d580c" />


출처:

[CQRS - 배달의 민족](https://blog.naver.com/kbh3983/222611980219)

[CQRS 패턴 알아보기](https://blog.leaphop.co.kr/blogs/69/CQRS_%ED%8C%A8%ED%84%B4_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0)
