# CQRS 패턴과 이벤트 소싱

## [1] CQRS란?

### CQRS 개념

Command Query Responsibility Segregation으로, 데이터에 대한 변경(Command)와 조회(Query) 작업을 구분하는 패턴이다.

- CQRS에서 Command 모델과 Query 모델은 서로 다른 데이터 접근 방식을 가진다.
- 클래스, 패키지, 서비스, 데이터 저장소 레벨 등에서 책임 분리가 가능하다.
- 시스템의 확장성, 성능, 유지보수성을 크게 향상 가능하다.

### 전통적인 CRUD의 문제점과 CQRS의 도입

- **단일 데이터 모델의 한계** : 하나의 데이터 모델과 저장소를 사용하여 복잡한 읽기 및 쓰기 작업을 모두 처리한다.
    
    ➡️ CQRS를 적용하면 읽기 작업과 쓰기 작업에서 독립적인 데이터베이스를 선택 가능하다.
    
- **복잡한 시스템에서의 성능 병목 현상** : 복잡한 조회 쿼리가 쓰기 성능에 영향을 끼친다.
    
    ➡️ CQRS를 적용하면 데이터 저장소 레벨에서 분리하는 등의 작업을 통해 읽기 작업을 따로 최적화할 수 있다.
    
- **확장의 어려움** : 읽기 쓰기의 서로 다른 확장 요구사항을 충족하기 어렵다.
    
    ➡️ CQRS를 적용하면 별도의 읽기 전용 DB나 서버를 두는 것이 가능하며, 트래픽 상황에 따라 유연하게 확장 가능하다. (수평확장성이 높아진다.)

### CQRS의 원리

1. **Command 모델** : 데이터를 변경하는 쓰기 작업(생성, 수정, 삭제)을 처리한다.
    - 특정 명령을 받아서 비즈니스 로직과 유효성 검사를 수행하고 데이터를 변경한다.
    - 도메인 로직을 반영하여 데이터의 일관성을 보장하는 데 중점을 둔다.
2. **Query 모델** : 데이터를 조회하는 읽기 작업(조회)을 수행한다.
    - 최적화된 읽기 작업을 위해 데이터를 별도의 형태로 저장할 수도 있다.
    - 데이터를 빠르게 조회하는 데 중점을 두며, 데이터 저장소의 구조와 일치할 필요가 없다.
- 각 모델별로 독립적인 데이터베이스, 기술 스택을 선택할 수 있다.
  
### CQRS의 구현 방법

**(1) Simple CQRS 아키텍처** : 단일 데이터저장소에서  Command와 Query를 코드 레벨에서만 분리

<img width="300" alt="image" src="https://github.com/user-attachments/assets/76b6dbbf-47f1-4db7-9b9d-f61c9cb3bc96" />

- DB의 ACID 특성에 의존하여 일관성을 유지한다.
- 장점 : 구현이 쉽다 (일반적인 MVC패턴에서도 쉽게 적용 가능)
- 단점 : 성능, 확장성 등 CQRS의 구조적 이점을 잘 살리지 못한다.

(2) **Separated Persistence CQRS** : Command와 Query의 데이터베이스를 분리하고, 두 데이터베이스의 데이터를 동기화 처리하는 방식

<img width="300" alt="image" src="https://github.com/user-attachments/assets/8e9c2275-2585-485e-879c-223e14698153" />

- 조회 서비스는 서비스에 맞는 저장소 선택 가능하므로 다수의 데이터베이스를 혼용하여 사용 할 수 있다.
- 장점 : Simple CQRS의 성능 및 확장성 문제를 해결할 수 있다.
- 단점 : 신뢰성이 보장되지 않을 수 있다.
    - 동기화 처리를 위한 Broker의 가용성과 신뢰도가 보장이 되어야한다.

(3) **Event Sourcing (이벤트 소싱)** : 모든 명령을 이벤트 형태로 별도의 이벤트 저장소에 저장하는 방식

<img width="400" alt="image" src="https://github.com/user-attachments/assets/75f44e2a-c8f8-40d6-8aef-16da5ab35507" />

- 이벤트만 이벤트 저장소에 저장하고, Event Handler가 이벤트를 구독해서 읽기 모델을 업데이트한다.
- 장점 : 이벤트 저장소에 저장된 Command들은 다시 사용할 수 있다.
- 단점 : 강한 일관성과 실시간 업데이트가 필요한 시스템에는 적합하지 않을 수 있다.

**[변경 전파 방법]**

1. API로 주기적으로 변경 사항을  polling ⇒ 부하 및 장애 전파, 결합도 증가, 동기화 지연 등 문제
2. Message Broker를 활용 (Kafka 활용)

## [2] Event Sourcing (이벤트 소싱)

상태 변경을 이벤트의 형태로 기록하고 관리하는 방식이다.

- 모든 상태 변화 기록(이벤트)을 순차적으로 저장하여 이후 필요 시 이벤트들을 재생하여 현재 상태를 유추한다
- 시스템의 상태를 정확하게 추적하고 변경 이력에 대한 기록을 남길 수 있어 복구, 디버깅, 감사 트레일에 매우 유용하다.
- 모든 이벤트를 다 기록하므로 저장공간이 많이 필요하며, 이벤트를 재생하여 시스템 상태를 재구성하는데 시간이 걸린다.

⇒ 데이터의 변경 이력이 중요한 애플리케이션에 적합 (EX. 금융 거래 시스템 등)

**[실제 사례] : “강남 언니” 어플리케이션**

- 미용의료 병원의 유동적인 내원 과정을 추적하고, 문제 발생 시 신속히 대응할 수 있도록 Audit Log와 이벤트 기반 기록이 필요함
    
    ⇒ 결제, 예약, 내원 흐름에 **이벤트 소싱**을 적용하여 과거 상태 재현 및 정확한 기록을 가능하게 함


### CQRS 와 함께 쓰이는 이유

- 이벤트 소싱 방식의 문제점 :
    - 이벤트 소싱은 이벤트만 저장하므로 현재 상태를 조회하려면 모든 이벤트를 순차적으로 재생해야한다.
    - Query마다 매번 이벤트 재생이 필요해 비효율적이므로 조회 전용 모델(읽기 모델)을 따로 구성할 필요성이 생긴다.
    - 이벤트 소싱에서는 Command를 통해 이벤트를 발생시키고, 이벤트를 기반으로 별도의 프로세스가 동작해 읽기 모델을 업데이트한다
    
    ⇒ 이벤트 소싱의 비효율성 문제를 CQRS의 Query 모델이 해결한다. 
    
- 시너지 효과
    - 확장성 : Command와 Query를 독립적으로 확장 가능하다.
    - 유연성 : 기존 이벤트 스트림으로부터 새로운 읽기 모델을 언제든지 생성할 수 있다.
    - 복원력 : 읽기 모델이 손상되어도 이벤트 저장소에서 재구성이 가능하다

### CQRS + 이벤트 소싱의 동작 과정
<img width="500" height="640" alt="image" src="https://github.com/user-attachments/assets/1aeaf3c4-b324-4e28-9566-ec479fa4236a" />

1. **사용자 명령(Command) 요청** : 사용자가 UI를 통해 상태 변경을 요청한다. (ex. 주문 생성, 상품 수량 변경 등)
2.** Command 처리** : Command Manager가 Command를 받아 로직에 따라 검증하고 처리하며, 이과정에서 도메인 이벤트를 생성한다.  (ex. 주문 생성됨, 수량 변경됨 등)
3. **Event 저장** : 이벤트는 이벤트 저장소에 순차적으로 저장된다.
4. **쓰기 모델 상태 재구성** : 이벤트 저장소에 저장된 이벤트들을 재생하여 상태를 복원한다.
5. **이벤트 발행** : 도메인 이벤트는 Event Bus를 통해 발행된다.
6. **읽기 모델 업데이트** : Event Bus를 구독하는 별도의 프로세스(Event Handler, Projection 등)가 읽기 모델을 업데이트한다.
7. **사용자 질의(Query) 요청 및 처리** : 사용자가 데이터 조회 요청을 보내면, Query Manager가 최신화된 읽기 모델에서 빠르게 데이터를 조회하여 UI에 응답한다.

- 읽기 모델의 경우, 조회 성능 최적화를 위해 쓰기 모델과는 다른 테이블 구조나 데이터 형식을 사용할 수 있다. (ex. 모두 하나의 테이블에 담기, JSON형식으로 구성하기 등)

### CQRS + 이벤트 소싱은 언제 사용해야 할까?

[적합한 상황]

- 복잡한 비즈니스 로직이 있는 도메인
- 감사 로그나 이력 추적이 중요한 시스템
- 읽기와 쓰기의 성능 요구사항이 크게 다른 경우
- 다양한 형태의 리포트나 뷰가 필요한 경우

[부적합한 상황]

- 단순한 CRUD 애플리케이션
- 강한 일관성이 필수인 시스템 (EX. 실시간 거래 시스템 등)
- 개발 및 운영 복잡도를 감당하기 어려운 소규모 프로젝트

---

https://www.msap.ai/docs/msa-expert-from-concepts-to-practice/part-1-msa-fundamentals/chapter-2-core-concepts-of-msa/section-2-5-data-management/subsection-2-5-2-cqrs-pattern/

https://littlemobs.com/blog/cqrs-pattern-introduction/

https://azderica.github.io/02-architecture-msa/

https://yoonnyoon.tistory.com/273

https://blog.leaphop.co.kr/blogs/69/CQRS_%ED%8C%A8%ED%84%B4_%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0

https://velog.io/@boo105/CQRS-%EC%99%80-Event-Sourcing

