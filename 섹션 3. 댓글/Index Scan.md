# Index Scan

## Index Scan이란?

테이블을 조회할 때 ,인덱스를 활용하여 데이터를 검색하는 방식

### Full Table Scan

테이블에 존재하는 모든 데이터를 읽어가면서 조건에 맞으면 결과로 추출하고, 조건에 맞지 않으면 버리는 방식
![image](https://github.com/user-attachments/assets/8fb46b57-3ec2-49bb-bb15-fcfc128be634)


- 인덱스를 거치지 않고 테이블 데이터에 직행하여 처음부터 끝까지 스캔하는 방식으로, 테이블의 모든 레코드를 순차적으로 조회
- 디스크 I/O 비용이 많이 발생하며 대량의 데이터를 처리할 때는 시스템 성능에 부정적인 영향을 미칠 수 있음
- 대량의 데이터에 접근할 때 Full Table Scan을 활용하면 인덱스를 통한 랜덤 엑세스가 발생하지 않아 이점이 있음

**[사용]**

- 대량의 데이터를 한번에 처리를 해야할 때
- 인덱스를 사용하여 데이터를 가져오는 것보다 테이블 전체를 스캔하는 것이 빠른 경우
- 테이블의 모든 데이터를 가져와야하는 경

### Index Scan

인덱스를 구성하는 컬럼의 값을 기반으로 데이터를 추출하는 엑세스 기법

- 인덱스를 활용하여 특정 데이터만 빠르게 검색하는 방식
- 인덱스는 DB 테이블에서 특정 열에 대한 정보를 가지고 있기 때문에 해당 열을 사용하여 검색할 경우 인덱스 스캔을 사용 가능

## Index Scan의 종류

### (1) Index Full Scan 인덱스 전체 스캔

인덱스의 모든 데이터를 읽어오는 방법
![image](https://github.com/user-attachments/assets/15ead858-6099-423b-8f2f-94aa692d6bd2)

- 테이블에 접근하지 않고 인덱스 내의 컬럼만 참조하여 처음부터 끝까지 스캔하여 데이터에 접근하는 방식
- 테이블의 일부 데이터를 사용하므로, 테이블 풀 스캔보다 유리

```sql
SELECT * FROM {테이블명} WHERE {인덱스 컬럼}
```

**[장점]** 인덱스의 크기가 작은 경우 빠른 검색 가능

**[단점]** 테이블의 크기가 큰 경우 전체 테이블 스캔보다 느릴 수 있음

- 데이터베이스의 성능에 영향을 미칠 수 있으며 인덱스를 효율적으로 사용하여 인덱스 전체 스캔이 발생하지 않도록 해야함

**[사용]**

- 인덱스를 사용하지 않고 전체 테이블을 검색해야할 때 발생
- 선택성이 낮아 일부 레코드만 가져올 때 발생

*** 선택성 : 인덱스 값이 얼마나 유일한지에 대한 지표. ex) 성별 : 선택성⬇️ / 전화번호 : 선택성⬆️*

### (2) Index Range Scan

인덱스의 일부 데이터만 읽어오는 방식으로, 인덱스의 범위를 지정하여 빠른 검색 가능
![image](https://github.com/user-attachments/assets/b8e1a935-9c8c-4712-860a-54cde07f0118)


- BETWEEN, LIKE, < 등을 사용했을 때, 인덱스 범위를 기준으로 스캔하고 스캔 결과를 토대로 테이블에 접근
- 특정 범위 내의 레코드만 읽어들이므로 비용이 적게 듦
- 선택성이 낮은 경우 전체 스캔이 발생할 수 있음

```sql
SELECT * FROM {테이블명} WHERE {인덱스 컬럼} BETWEEN {범위 시작값} AND {범위 종료값}
```

**[장점]** 인덱스의 크기와 테이블의 크기에 관계없이 빠른 검색 가능

**[단점]** 검색 범위가 넓을 경우 느릴 수 있음

**[사용]**

- WHERE절에서 범위 검색
- ORDER 절에서 정렬
- JOIN 연산

### (3) Index Unique Scan

인덱스의 유일한 값을 검색하는 방법

![image](https://github.com/user-attachments/assets/7f2112de-f921-46ef-bcb8-8a2ab3129729)

- WHERE문에 =을 사용했을 때나 기본키, 고유 인덱스로 테이블에 접근하는 방식
- 인덱스를 사용하는 방식 중 가장 효율적인 스캔 방식.

```sql
SELECT * FROM {테이블명} WHERE {인덱스 컬럼} = {검색값}
```

**[장점]** 인덱스의 크기와 테이블의 크기에 관계없이 빠른 검색 가능

**[단점]** 인덱스 컬럼이 유일한 값을 가지고 있을 때만 사용 가능

**[사용]**

- PRIMARY KEY나 UNIQUE 인덱스를 사용하여 조회
- 인덱스에서 단일 값을 검색할 때

### (4) Index Loose Scan (Index Skip Scan)

인덱스의 일부 데이터만 읽어오는 방식으로, 인덱스의 범위를 지정하지 않고 검색을 수행

![image](https://github.com/user-attachments/assets/a295864e-342a-4375-9146-a6d6895f46bd)

- 인덱스에서 필요한 부분만 선택하여 스캔하는 방식
- 인덱스 범위 스캔과 비슷하게 특정 인덱스 범위만 스캔하지만, 필요없는 인덱스 키 값을 건너 뛰고 다음으로 넘어가 검색을 수행
- WHERE 조건문 기준으로 필요한 데이터와 불필요한 데이터를 구분한 뒤 불필요한 인덱스 키는 무시

```sql
SELECT * FROM {테이블명} WHERE {인덱스 컬럼} LIKE '%{검색어}%'
```

**[장점]** 인덱스의 크기와 테이블의 크기에 관계없이 빠른 검색 가능

**[단점]** 정확도가 떨어질 수 있음

**[사용]**

- WHERE절에 LIKE 키워드로 특정 문자열 조회
- GROUP BY, MAX, MIN 함수 포함

### (5) Index Merge Scan

여러 개의 인덱스를 병합하여 검색하는 방법

![image](https://github.com/user-attachments/assets/015dc735-0fd9-478f-8f5a-796b7e891223)

- WHERE문의 조건 열이 서로 다른 인덱스에 존재할 때 사용됨.
- 각 인덱스를 병합하는데 시간이 걸리기 때문에 전체적인 속도가 느릴 수 있으나 각각의 인덱스를 사용하는 것보다 효율적

```sql
SELECT *
FROM {테이블명}
WHERE {인덱스 컬럼1} = {검색값1}
AND {인덱스 컬럼2} = {검색값2};
```

**[장점]** 복잡한 검색 조건을 처리할 수 있음

**[단점]** 인덱스의 크기가 작은 경우에만 유용하며, 병합에 시간이 걸릴 수 있음

**[사용]**

- OR 조건이 포함된 쿼리에서 각각의 조건에 해당하는 인덱스를 사용
- UNION ALL 연산자를 사용하는 경우

## Backward Index Scan : 역방향 인덱스 스캔

### Backward Index Scan이란?

인덱스에서 데이터를 역순(내림차순)으로 조회하는 방식

- 일반적으로 `ORDER BY DESC` 쿼리를 실행할 때 사용
- B-Tree 인덱스를 사용할 경우 기본적으로 지원됨

### Backward Index Scan이 필요한 이유

데이터베이스 인덱스는 기본적으로 오름차순으로 정렬되어 있으므로 ORDER BY DESC를 사용할 경우 인덱스를 뒤에서부터 읽어야함.

⇒ 인덱스를 활용하지 않으면 정렬 연산이 필요하므로 성능 저하 가능
