# Primary Key 생성 전략

## DB Auto_increment

: 데이터베이스가 자동으로 증가하는 숫자를 부여하여 PK를 생성하는 방식

- 데이터가 삽입될 때 자동으로 증가하는 번호가 할당되며, 삭제된 값은 자동으로 복구되지 않음.

### 장점

- 관리가 간편하며, 단일 데이터베이스 환경에서 성능이 우수함.
- 정렬된 상태를 유지하므로 B+ Tree 기반 인덱스 성능 최적화 가능
- 데이터 삽입 속도가 빠름

### 단점

- **분산 환경에서의 중복 문제** : 분산 데이터베이스 환경에서는 PK가 중복되어 식별자의 유일성이 보장되지 않음. (EX. Shard 1의 article_id=1 와 Shard 2의 article_id=1)
- **보안 문제** : PK를 클라이언트 측에 노출 시 데이터 개수나 특별 시점의 식별자 예측 가능

**💡해결방법 - PK와 UNIQUE INDEX 사용**

- PK만 DB내의 식별자로 사용하고, 애플리케이션에서의 식별자를 위해 별도의 UNIQUE 인덱스를 사용
    
    EX) `PK = id(DB auto_increment)`  /  `unique index = article_id(UUID 등)` 으로 설정하고 unique index만 클라이언트에 노출
    
- 이 경우, Secondary Index로 포인터를 찾은 후, Clustered Index로 데이터에 접근하므로 조회비용이 증가

### 사용

- 애플리케이션에서 PK의 중복을 직접 구분하는 상황
- 단일 데이터베이스 환경 (ex. 개인 블로그, 사내 시스템 등)
- 보안 요구사항이 낮은 시스템

## 유니크 문자열 또는 숫자

: PK를 고유한 문자열(UUID) 또는 난수를 생성하여 지정하는 방법

- 정렬 데이터가 아니라 랜덤 데이터를 삽입
    - UUID v4 : 랜덤 , UUID v7 : 시간 기반(정렬)

**[UUID]**

: 128비트의 고유한 문자열을 생성하는 알고리즘

- 랜덤성이 강하여 충돌 확률이 매우 낮고, 길이가 길어 인덱싱 성능이 저하될 수 있음.

### 장점

- 키 생성 방식이 간단함

### 단점

- 랜덤 데이터로 인해 성능 저하 발생 가능
    - 데이터 삽입 시 B+tree 재구성 및 디스크 I/O 증가
    - PK 범위 조회시, 랜덤 I/O로 성능 저하

## 유니크 정렬 문자열

PK를 생성할 때 각 ID가 고유하면서도 생성된 순서대로 정렬이 가능하도록 만드는 방식

- 128bit 알고리즘
- UUID 처럼 고유성을 유지하면서도 정렬이 가능하도록 시간 기반의 요소를 포함하는 것이 핵심

**[UUID v7]**

: 시간 기반으로 생성되는 UUID로, 새성시간을 포함하여 정렬할 수 있는 기능을 제공하는 방식

- 생성시간을 추적할 수 있는 기능을 제공

**[ULID]** 

: ULID는 UUID보다 짧고, 생성 순서대로 정렬이 가능한 ID 방식

- 26자로 UUID보다 짧음
- 특수문자가 없는 URL-safe
- 예시 : 01F8MECHZX3TBXYN5RRTG1X3J6

### 장점

- 분산 환경에 대한 PK 중복 문제 해결
- 보안 문제 해결
- 랜덤 데이터에 의한 성능 문제 해결
- ID가 일정한 패턴을 가지므로 AUTO_INCREMENT와 유니크 문자열 또는 숫자 방식보다 인덱싱 성능이 더 좋음

### 단점

- PK가 크면 클수록 데이터는 더 많은 공간을 차지
- PK가 크면 클수록 비교 연산에 의한 정렬/조회에 더 많은 비용 소모

### 사용

- UUID v7은 NoSQL과 같은 분산 데이터 저장소에서 많이 사용됨
- ULID는 이벤트 로그 등 순차적인 데이터 삽입이 필요한 경우 유용


## 유니크 정렬 숫자

: PK를 생성할 때 각 ID가 고유하면서도 생성된 순서대로 정렬이 가능하도록 만드는 방식

- 숫자 기반 ID를 사용하여 생성된 순서대로 정렬이 가능하도록 설계됨
- 64bit를 사용

**[Snowflake]** 

: 분산 시스템에서 고유한 64비트 ID를 생성하는 알고리즘

- [1비트][41비트: 타임스탬프][10비트: 노드 ID][12비트: 시퀀스 번호]
- 분산 환경에서도 중복 없이 순차적 ID 생성하기 위한 규칙
    - 타임스탬프 : 순차성
    - 노드ID + 시퀀스 번호 : 고유성
- 예시 : 146789123456789012
- 19자로 구성
- 시간 기반 정렬 가능, 성능 최적화

**[TSID]**

: Twitter의 Snowflake와 ULID spec을 합쳐 만든 자바의 라이브러리

- 대규모 분산 시스템에서의 병렬 처리 가능 및 고유성 보장
- 공간 효율성 O (통상 8바이트)
- 시간이 지남에 따라 점점 커지는 값이기 때문에 정렬의 이점 모두 활용 가능

### 장점

- 분산 환경에 대한 PK 중복 문제 해결
- 보안 문제 해결
- 랜덤 데이터에 의한 성능 문제 해결
- UUID보다 작은 크기(64bit)로 인덱스 성능 최적화 가능
- 생성된 순서대로 정렬 가능

### 단점

- 정렬을 위해 타임스탬프를 나타내는 비트 수의 제한으로, 키 생성을 위한 시간적인 한계 발생 가능

### 사용

- MSA 기반 분산환경에서 고유 식별자로 사용
- 대규모 데이터 저장소에서 PK 성능 최적화가 필요한 경우 사용
- 고성능 시스템, 금융 서비스, 로그 저장 등에 적합

## 비교

### 🔹 **데이터베이스 환경에 따른 PK 선택 기준**

| 환경 | 고려해야 할 사항 | 적합한 PK 생성 방식 |
| --- | --- | --- |
| **단일 데이터베이스 (Standalone DB)** | 단일 노드에서 동작하므로 PK 충돌 가능성이 없으므로 단순한 정수형 PK가 성능적으로 유리함. | ✅ Auto-Increment ID ✅ 유니크 정렬 숫자 (고유 ID 생성 필요 시) |
| **분산 데이터베이스 (Sharded DB, Multi-Node DB)** | - 여러 노드에서 동일한 PK가 생성될 가능성이 있음. - PK의 유일성이 보장되어야 함. - Auto-Increment 방식은 충돌 가능성이 있음. | ✅ 유니크 정렬 숫자 ✅ 유니크 정렬 문자열 |
| **대규모 트래픽 처리 (High Throughput)** | - PK가 정렬되지 않으면 인덱스 성능 저하. - Clustered Index에서 랜덤 삽입이 발생하면 성능 저하. - 트랜잭션이 많을 경우 PK 생성 성능도 중요. | ✅ 유니크 정렬 숫자 ✅ 유니크 정렬 문자열 |
| **보안이 중요한 시스템** | - ID를 노출할 경우 정보 유출 가능. - Auto-Increment 사용 시, 사용자가 데이터 개수를 유추할 수 있음. | ✅ 유니크 문자열 또는 숫자 ✅ 별도 Unique Index 추가 (PK 노출 방지) |
| **PK 기반 Range Query(범위 조회) 필요** | - 정렬된 데이터가 필요. - Auto-Increment는 정렬을 보장하지만, 분산 환경에서는 사용 어려움. | ✅ 유니크 정렬 숫자 ✅ 유니크 정렬 문자열 |

### PK 생성 방식별 성능 비교
| PK 방식 | **삽입 성능 (Insert Performance)** | **조회 성능 (Read Performance)** | **인덱스 크기 (Index Size)** | **보안성 (Security)** | **분산 환경 적합성** |
| --- | --- | --- | --- | --- | --- |
| **Auto-Increment (DB 자체 증가값)** | ✅ 빠름 (순차 삽입) | ✅ 빠름 (정렬된 인덱스) | 🔹 작음 (4~8 bytes, INT/BIGINT) | ❌ 낮음 (데이터 개수 유추 가능) | ❌ 낮음 (샤딩 환경에서 충돌 발생 가능) |
| **UUID (랜덤)** | ❌ 느림 (랜덤 삽입으로 인덱스 분할 발생) | ❌ 느림 (랜덤 조회로 인한 디스크 I/O 증가) | ❌ 큼 (16 bytes, VARCHAR) | ✅ 높음 (ID 예측 불가) | ✅ 높음 (유일성 보장) |
| **UUID v7, ULID (정렬된 UUID)** | 🔹 보통 (순차 삽입 가능) | 🔹 보통 (UUID보다는 성능 향상) | ❌ 큼 (16 bytes, VARCHAR) | ✅ 높음 (ID 예측 어려움) | ✅ 높음 (샤딩 환경에서 충돌 없음) |
| **Snowflake, TSID (정렬된 숫자 기반 ID)** | ✅ 빠름 (순차 삽입) | ✅ 빠름 (정렬된 인덱스) | ✅ 작음 (8 bytes, BIGINT) | ✅ 높음 (랜덤한 값 포함 가능) | ✅ 높음 (유일성 보장) |

### 결론
- **단일 DB, 간단한 시스템** → Auto-Increment
- **대규모 트래픽, 범위 조회 필요** → 유니크 정렬 숫자
- **보안이 중요한 서비스** → 유니크 정렬 문자열
- **분산 환경에서 PK 충돌 방지** → 유니크 정렬 숫자 , 유니크 정렬 문자열
