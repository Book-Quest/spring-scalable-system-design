## 조회수의 특징

- 다른 데이터에 의해 파생되는 데이터가 아님
    - 그래서 트랜잭션이 반드시 필요하지 않음
- 트래픽이 많음
    - 디스크는 접근 비용이 비싸기 때문에 더 빠른 저장소 고려

<img width="488" alt="image" src="https://github.com/user-attachments/assets/52fd7e92-9dac-483d-8856-c293436c77bd" />

## Redis의 특징

- In-memory DB: 데이터를 메모리에 저장하고 관리
- NoSQL: 관계형 데이터베이스와 달리 정해진 스키마 X ⇒ 유연하게 데이터 모델 사용 가능
- 키 - 값 저장소
- 다양한 자료 구조 지원: String, List, Set, Sorted, Set, Hash 등
- TTL(Time To Live) 지원: 일정 시간이 지나면 데이터 자동 삭제
- Single Thread: 단일 스레드에서 각 명령어를 순차적 처리, 동시성 문제 해결 유리
- 데이터 백업 지원: 메모리는 휘발성이지만, Redis는 데이터를 디스크에 저장하는 방법도 제공 (AOF, RDB)
- Redis Cluster: 확장성, 부하 분산, 고가용성을 위한 분산 시스템 구성 방법 제공

## Redis 사용 사례

### 고성능 작업

- 메모리는 디스크보다 빠르기 때문에, Redis 자체를 DB로 사용 가능
- Single Therad로 동작하기 때문에 동시성 문제를 다루는데 유리

### 캐시

- 더 느린 저장소에서 더 빠른 저장소에 데이터를 저장해두고 접근하는 기술
- Redis는 데이터를 일정 시간 캐시할 수 있음 ⇒ 디스크에서 읽어오는 것보다 빠르게 처리

### pub/sub

- Redis는 메시지를 발행 및 구독할 수 있기 때문에 실시간 통신에도 활용 가능

---

![image (1)](https://github.com/user-attachments/assets/8d29d8fc-6201-4ff7-9534-701d78196186)


- "Publish/Subscribe"의 줄임말, **발행/구독 메시징 패턴**.
- 발행자(Publisher)와 구독자(Subscriber)가 **직접 연결되지 않고**, 메시지를 중간 매개자(Broker)를 통해 주고받는 구조
- "누가 메시지를 보내는지", "누가 받는지" 서로 몰라도 작동하는 구조

---

### 🔧 핵심 구성 요소

1. **Publisher (발행자)**
    - 메시지를 생성해서 특정 주제(Topic)에 발행함.
2. **Subscriber (구독자)**
    - 특정 주제(Topic)를 구독하고 있다가, 해당 주제에 메시지가 발행되면 이를 수신함.
3. **Broker (중개자)**
    - 메시지를 받아서 구독자들에게 전달함.
    - 예: Kafka, Redis Pub/Sub, RabbitMQ, Google Pub/Sub 등.

---

### 📦 예시

- **카카오톡 알림 서비스**
    - 발행자: 서버에서 "새 메시지 도착" 이벤트를 발행
    - 주제(Topic): 사용자 알림
    - 구독자: 앱에 로그인한 사용자
    - 브로커: 메시징 시스템 (예: Kafka)

---

### ✅ 장점

- **느슨한 결합 (Loose Coupling)**: 발행자와 구독자가 서로를 몰라도 됨.
- **확장성 좋음**: 구독자가 많아도 시스템이 유연하게 대응 가능.
- **비동기 처리에 적합**: 처리량이 많거나 병렬 처리에 강함.

### ❗단점

- **디버깅 어려움**: 누가 메시지를 받았는지 추적이 어려움.
- **지연 가능성**: 중간 브로커를 거치므로 실시간성과는 트레이드오프가 있음

---

## Kafka vs Redis Pub/Sub 비교

**Kafka의 Pub/Sub 모델**

![image (2)](https://github.com/user-attachments/assets/accc63fa-01de-458d-83ad-8d82b4c240ca)


**Redis의 Pub/Sub 모델**

![image (3)](https://github.com/user-attachments/assets/e4cc6d6d-ef55-4ec5-bb97-7dac58104393)


### 메시지 흐름 구조 차이

**Kafka**

```css
Publisher → Kafka Broker(디스크 저장) → [Consumer Group 1] (오프셋으로 관리)
                                                      → [Consumer Group 2]
```

- 메시지는 **디스크에 저장**
- 각 Consumer Group이 **자신만의 offset**으로 읽음
- **같은 메시지를 여러 구독자가 서로 다르게 읽을 수 있음**

**Redis**

```css
Publisher → Redis Broker(메모리) → [Subscriber 1]
                                  → [Subscriber 2]
```

- **발행 시점에 연결된 구독자**에게만 메시지를 보냄
- 구독자가 없으면 **메시지는 사라짐**
- 과거 메시지 **조회 불가**

|  | **Kafka** | **Redis** |
| --- | --- | --- |
| **목적** | 대용량 로그/이벤트 스트리밍 처리용 | 가벼운 실시간 메시지 전달용 |
| **브로커 저장** | **디스크에 저장 (내구성 보장)** | **메모리 기반 (비영속성)** |
| **메시지 보존** | 메시지 소비 여부와 관계없이 보존 가능 | 구독자가 없으면 메시지 **소실**됨 |
| **메시지 보장** | **At-least-once / Exactly-once 보장 가능** | 보장 없음 (Best-effort) |
| **구독자 처리** | 구독자가 나중에 읽을 수 있음 (consumer offset 관리) | 실시간 수신만 가능, 과거 메시지 불가 |
| **스케일링** | 파티션 기반 수평 확장 가능 | 수평 확장 어려움 |
| **복잡도** | 비교적 복잡 (토픽, 파티션, 오프셋 등 설정 필요) | 매우 단순함 (Topic만 지정하면 끝) |

출처:

[PUB/SUB, 잘 알고 쓰자!](https://medium.com/frientrip/pub-sub-%EC%9E%98-%EC%95%8C%EA%B3%A0-%EC%93%B0%EC%9E%90-de9dc1b9f739)

---

## Redis Cluster - Distributed In-memory Database

- 여러 개의 Redis 서버가 클러스터를 이루면서 분산 시스템을 이룸
- 확장성을 위해 논리적 샤딩을 지원

### Redis Cluster의 샤딩 방식

- Redis Cluster는 데이터를 여러 노드에 자동으로 분산시키는 **샤드 기반 분산 구조**
- 클러스터 전체는 16,384개의 해시 슬롯(hash slot)**으로 구성
- 각 노드가 하나 이상의 해시 슬롯을 담당하면서 **논리적으로 샤드 역할**을 수행

### 특징

- 각 **Redis 노드**는 이 16,384개 슬롯 중 일부를 담당 → 이게 바로 **샤딩**
- **자동 리밸런싱**, **노드 추가/삭제** 가능
- 데이터 복제도 지원, 장애 시에도 유연하게 대처할 수 있는 고가용성을 제공

### Redis의 데이터 백업

- AOF (Append Only File) : 수행된 명령어를 로그 파일에 기록, 데이터 복구를 위해 로그를 재실행
- RDB (Snapshot): 저장된 데이터를 주기적으로 파일에 저장

## MySQL에 백업

- 약간의 데이터 유실은 허용 가능하기 때문에, 실시간 백업 필요 X

### 시간 단위 백업

- N분 단위로 Redis → MySQL 백업
- 배치 or 스케줄링 시스템 구축 필요
- 백업 전 장애 시, 유실될 수 있음

### 개수 단위 백업

- N개 단위로 Redis의 데이터를 MySQL로 백업
- 조회 시점에 간단히 처리 가능
- 백업 전 장애 시 or 개수 단위 안 채워질 시 유실될 수 있음

## 어뷰징 여부를 식별하는 법

- 로그인 이용자
- 비로그인 이용자
    - IP, User-Agent, 브라우저 쿠키, 토큰

### MySQL(DB) 활용법

- 조회수 증가 요청이 오면, 마지막 조회 시점 조회
- 10분 이내의 조회 내역이 있는지 확인
- 조회 내역이 없다면, 조회수 증가 후 현재 시간을 마지막으로 조회시점 업데이트
- 조회내역이 있다면, 조회수 증가 X

### MySQL 사용시 단점

- MySQL을 사용하면 조회 트래픽 문제와 동시성 문제 발생.
- 데이터 자동 삭제를 지원하지 않아서 삭제 되거나 더 갱신될 일이 없다면 데이터가 영구히 남음 ⇒ 삭제 시스템 구현 필요
- Redis는 TTL(Time To Live)를 지원 ⇒ 별도 구현 없이 데이터 자동 삭제

## Redis 활용법

- 조회수 증가 요청이 오면, Redis에 TTL = 10분으로 데이터 저장
    - 게시글 조회는 사용자 단위로 식별, key=(articleId+userId)
    - 이미 저장된 데이터가 있으면, 저장에 실패하는 명령어(setIfAbsent) 사용
- 데이터 저장 성공여부에 따라서 조회수의 증감을 결정
    - 성공시: 조회 내역 x, 조회수 증가
    - 실패시: 조회 내역 o, 조회수 증가 x
    

### Redis 사용한 조회수 어뷰징 정책

- 사용자의 게시글 조회수 증가에 대해 Lock 획득
- Scale-out을 고려한 환경, 조회수 서비스는 여러 개의 서버 애플리케이션으로 구성 ⇒ 확장성을 고려한 분산 시스템
- Distributed Lock: 분산 시스템에서 락을 획득
- Redis는 Single Thread로 동작, setIfAbsent는 원자적으로 처리되기 때문에 원자성 고려할 필요 없음
